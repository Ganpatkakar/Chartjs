<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>Table and chart by month</title>
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="css/bootstrap.min.css">
	<style>
		#linechartcomparision,
		#linechart,
		#barchart,
		#piechart,
		#multibarchart {
			position: relative;
		}
		
		#canvas1 {
			position: absolute;
		}
		
		#canvasupper1 {
			position: absolute;
			cursor: default;
		}
		
		.canvas {
			position: absolute;
		}
	</style>
</head>

<body>
	<div id="container" class="container">
		<section class="row">
			<div id="linechartcomparision" class="col-sm-6"></div>
			<div id="linechart" class="col-sm-6"></div>
		</section>
		<section class="row">
			<div id="barchart" class="col-sm-6"></div>
			<div id="multibarchart" class="col-sm-6"></div>
		</section>
		<section class="row">
			<div id="piechart" class="col-sm-6"></div>
			<div id="donutchart" class="col-sm-6"></div>
		</section>
		<section class="row">
			<div id="splinechart" class="col-sm-6"></div>
			<div id="meterchart" class="col-sm-6"></div>
		</section>
	</div>
	<!-- jQuery library -->
	<script src="js/jquery.min.js"></script>
	<!-- Latest compiled and minified JavaScript -->
	<!--<script src="js/bootstrap.min.js"></script>-->
	<script>
		//$('.container').html(prepSurface(1, 400, 300));
		//Prepare surface or canvas element with javascript
		/*what is required :- 
		1. Class or ID for chart container.
		2. Canvas container creation.
		3. Canvas ID or class to set internal chart.
		4. Chart variables and details.
		5. Chart type from client side.
		*/
		var charts = {
			"container": "linechartcomparision"
			, "chartnumber": 1
			, "type": 'linechartcomparision'
			, "title": {
				"text": "line chart Comparision"
			},
			"yaxis" : {
				"min" : 0,
				"max" : 3,
				"difference" : 1,
				"title" : "Days"
			},
			"xaxis" : {
				"categories" : ["gfee", "fusionfoods"]
			}
			, "wid": 500
			, "hei": 400
			, "data": [
				{
					"stroke": "#ff0000"
					, "datapoints": [
						{
							"lable": "Actual"
							, "ylable": ''
							, "y": 0
						}
						, {
							"lable": "Actual1"
							, "ylable": ''
							, "y": 1
						}
							]
					}
				, {
					"stroke": "#00ff00"
					, "ydataname": "Days"
					, "datapoints": [
						{
							"lable": "planed"
							, "y": 2
						}
						, {
							"lable": "planed2"
							, "y": 3
						}
							]
					}

				]
		}
		chartCalling(charts);
		var chartline = {
			"container": "linechart"
			, "chartnumber": 2
			, "type": 'linechartcomparision'
			, "title": {
				"text": "line Chart"
			},
			"yaxis" : {
				"min" : 0,
				"max" : 8,
				"difference" : 1,
				"title" : "Hours"
			},
			"xaxis" : {
				"categories" : ["lablename1", "la2", "lablename3", "lablename4", "lablename5", "lablename6"]
			}
			, "wid": 500
			, "hei": 400
			, "data": [
				{
					"stroke": "#ff0000"
					, "datapoints": [
						{
							"lable": "lablename1"
							, "y": 100
						}
						, {
							"lable": "lablename2"
							, "y": 90
						}
						, {
							"lable": "lablename3"
							, "y": 45
						}
						, {
							"lable": "lablename4"
							, "y": 52
						}
						, {
							"lable": "lablename5"
							, "y": 72
						}
						, {
							"lable": "lablename6"
							, "y": 85
						}
							]
					}

				]
		}
		chartCalling(chartline);
		var chartbar = {
			"container": "barchart"
			, "chartnumber": 3
			, "type": 'barchart'
			, "title": {
				"text": "Bar Chart"
			},
			"yaxis" : {
				"min" : 0,
				"max" : 8,
				"difference" : 1,
				"title" : "Hours"
			},
			"xaxis" : {
				"categories" : ["la1", "lablename2", "lablename3", "lablename4", "lablename5", "lablename6", "lablename7", "lable8", "lable9"]
			}
			, "wid": 500
			, "hei": 400
			, "data": [{
				"stroke": "#ff0000"
				, "datapoints": [{
					"lable": "lablename1"
					, "y": 100
				}, {
					"lable": "lablename2"
					, "y": 90
				}, {
					"lable": "lablename3"
					, "y": 45
				}, {
					"lable": "lablename4"
					, "y": 52
				}, {
					"lable": "lablename5"
					, "y": 72
				}, {
					"lable": "lablename6"
					, "y": 85
				}, {
					"lable": "lablename7"
					, "y": 95
				}, {
					"lable": "lablename8"
					, "y": 95
				}, {
					"lable": "lablename9"
					, "y": 95
				}]
			}]
		}
		chartCalling(chartbar);
		var multilinebar = {
			"container": "multibarchart"
			, "chartnumber": 5
			, "type": 'barchart'
			, "title": {
				"text": "Multi Line Bar Chart"
			},
			"yaxis" : {
				"min" : 0,
				"max" : 8,
				"difference" : 1,
				"title" : "Hours"
			},
			"xaxis" : {
				"categories" : ["lablename1", "lablename2", "lablename3", "lablename4", "lablename5", "lablename6", "lablename7", "lablename8"]
			}
			, "wid": 500
			, "hei": 400
			, "data": [
				{
					"stroke": "#b84335"
					, "datapoints": [
						{
							"lable": "lablename1"
							, "y": 100
						}
						, {
							"lable": "lablename2"
							, "y": 90
						}
						, {
							"lable": "lablename3"
							, "y": 45
						}
						, {
							"lable": "lablename4"
							, "y": 52
						}
						, {
							"lable": "lablename5"
							, "y": 72
						}
						, {
							"lable": "lablename6"
							, "y": 85
						}
						, {
							"lable": "lablename7"
							, "y": 95
						}
						, {
							"lable": "lablename8"
							, "y": 95
						}
							]
					}
				, {
					"stroke": "#fbbc05"
					, "datapoints": [
						{
							"lable": "lablearr1"
							, "y": 110
						}
						, {
							"lable": "lablearr2"
							, "y": 30
						}
						, {
							"lable": "lablearr3"
							, "y": 15
						}
						, {
							"lable": "lablearr4"
							, "y": 92
						}
						, {
							"lable": "lablearr5"
							, "y": 12
						}
						, {
							"lable": "lablearr6"
							, "y": 150
						}
						, {
							"lable": "lablearr7"
							, "y": 55
						}
						, {
							"lable": "lablearr8"
							, "y": 55
						}
							]
					}
				, {
					"stroke": "#4285f4"
					, "datapoints": [
						{
							"lable": "lablearr1"
							, "y": 11
						}
						, {
							"lable": "lablearr2"
							, "y": 38
						}
						, {
							"lable": "lablearr3"
							, "y": 45
						}
						, {
							"lable": "lablearr4"
							, "y": 62
						}
						, {
							"lable": "lablearr5"
							, "y": 22
						}
						, {
							"lable": "lablearr6"
							, "y": 10
						}
						, {
							"lable": "lablearr7"
							, "y": 95
						}
						, {
							"lable": "lablearr8"
							, "y": 25
						}
							]
					}
				, {
					"stroke": "teal"
					, "datapoints": [
						{
							"lable": "lablearr1"
							, "y": 18
						}
						, {
							"lable": "lablearr2"
							, "y": 40
						}
						, {
							"lable": "lablearr3"
							, "y": 25
						}
						, {
							"lable": "lablearr4"
							, "y": 22
						}
						, {
							"lable": "lablearr5"
							, "y": 92
						}
						, {
							"lable": "lablearr6"
							, "y": 70
						}
						, {
							"lable": "lablearr7"
							, "y": 35
						}
						, {
							"lable": "lablearr8"
							, "y": 75
						}
							]
					}

				]
		}
		chartCalling(multilinebar);
		var piechart = {
			"container": "piechart"
			, "chartnumber": 4
			, "type": 'piechart'
			, "title": {
				"text": "Pie Chart"
			}
			, "wid": 500
			, "hei": 300
			, "data": [{
				"stroke": "#ff0000"
				, "datapoints": [{
					"lable": "lablename1"
					, "y": 600
					, "color": "teal"
				}, {
					"lable": "lablename2"
					, "y": 90
					, "color": "#b84335"
				}, {
					"lable": "lablename3"
					, "y": 45
					, "color": "#fbbc05"
				}, {
					"lable": "lablename4"
					, "y": 52
					, "color": "#4285f4"
				}, {
					"lable": "lablename5"
					, "y": 85
					, "color": "#3a87ad"
				}, {
					"lable": "lablename6"
					, "y": 60
					, "color": "#34a853"
				}, {
					"lable": "lablename7"
					, "y": 188
					, "color": "#4285f4"
				}, {
					"lable": "lablename8"
					, "y": 85
					, "color": "#3a87ad"
				}, {
					"lable": "lablename9"
					, "y": 60
					, "color": "#34a853"
				}]
			}]
		}
		chartCalling(piechart);
		var donut = {
			"container": "donutchart"
			, /*Give exact id of you container div*/ "chartnumber": 6
			, /*Never keep it same with other charts*/ "type": 'donutchart'
			, /*keep same names as instructed - donutchart, linechartcomparision, barchart, piechart*/ "title": {
				"text": "Donut Chart"
			}
			, "wid": 500
			, "hei": 300
			, "data": [ /*Give as required data in given formate, syntax error with json will cause of error in charts*/
				{
					"stroke": "#ff0000"
					, "datapoints": [
						{
							"lable": "lablename1"
							, "y": 120
							, "color": "teal"
						}
						, {
							"lable": "lablename2"
							, "y": 90
							, "color": "#b84335"
						}
						, {
							"lable": "lablename3"
							, "y": 45
							, "color": "#fbbc05"
						}
						, {
							"lable": "lablename4"
							, "y": 520
							, "color": "#4285f4"
						}
						, {
							"lable": "lablename5"
							, "y": 0
							, "color": "#3a87ad"
						}
						, {
							"lable": "lablename6"
							, "y": 60
							, "color": "#34a853"
						}
							]
					}

				]
		}
		chartCalling(donut);
		var splinechart = {
			"container": "splinechart"
			, "chartnumber": 7
			, "type": 'splinechart'
			, "title": {
				"text": "Spline Chart"
			}
			, "wid": 500
			, "hei": 300
			, "data": [
				{
					"stroke": "#ff0000"
					, "datapoints": [
						{
							"lable": "lablename1"
							, "y": 100
						}
						, {
							"lable": "lablename2"
							, "y": 90
						}
						, {
							"lable": "lablename3"
							, "y": 45
						}
						, {
							"lable": "lablename4"
							, "y": 52
						}
						, {
							"lable": "lablename5"
							, "y": 72
						}
						, {
							"lable": "lablename6"
							, "y": 85
						}
						, {
							"lable": "lablename7"
							, "y": 95
						}
						, {
							"lable": "lablename8"
							, "y": 150
						}
						, {
							"lable": "lablename9"
							, "y": 77
						}
							]
					}

				]
		}
		chartCalling(splinechart);
		var meter = {
			"container": "meterchart"
			, /*Give exact id of you container div*/ "chartnumber": 8
			, /*Never keep it same with other charts*/ "type": 'meterchart'
			, /*keep same names as instructed - donutchart, linechartcomparision, barchart, piechart*/ "title": {
				"text": "Meter Gauge Chart"
			}
			, "wid": 500
			, "hei": 500
			, "data": [ /*Give as required data in given formate, syntax error with json will cause of error in charts*/
				{
					"stroke": "#ff0000"
					, "datapoints": [
						{
							"lable": "Poor"
							, "y": 25
							, "color": "#ff0000"
						}
						, {
							"lable": "Blw Avg"
							, "y": 25
							, "color": ""
						}
						, {
							"lable": "Average"
							, "y": 25
							, "color": "#00ff00"
						}
						, {
							"lable": "Abv Avg"
							, "y": 15
							, "color": "#00ff00"
						}
						, {
							"lable": "Exceed"
							, "y": 10
							, "color": "#00ff00"
						}
					]
					, dataval: 80
				}
			]
		}
		chartCalling(meter);

		function chartCalling(chart) {
			var charttype = chart.type;
			//console.log(charttype);
			if (charttype == 'linechartcomparision') {
				$('#' + chart.container).css({
					'height': chart.hei + 100
				});
				$('#' + chart.container).html('<h2>' + chart.title.text + '</h2>');
				var ctx = preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);
				var verticaldevisions = chart.yaxis.max;
				drawGrid(chart.chartnumber, verticaldevisions, ctx, chart.data);
				var canvas = 'canvas' + chart.chartnumber;
				var maxdata = [];
				maxdata[0] = maxdata[1] = chart.data[0].datapoints[0].y;
				for (var i = 0; i < chart.data.length; i++) {
					for (var j = 0; j < chart.data[i].datapoints.length; j++) {
						if (chart.data[i].datapoints[j].y < maxdata[0]) {
							maxdata[0] = chart.data[i].datapoints[j].y;
						}
						if (chart.data[i].datapoints[j].y > maxdata[1]) {
							maxdata[1] = chart.data[i].datapoints[j].y;
						}
					}
				}
				//console.log(maxdata);
				var linecord = [];
				for (var i = 0; i < chart.data.length; i++) {
					drawGraphicLinear(canvas, ctx, verticaldevisions, chart.data[i], maxdata, chart.data[i].stroke, linecord);
				}
				
				drawGraphicLinearYcord(canvas, ctx, verticaldevisions, chart);
				//console.log(linecord);
				var ctx = preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);
				drawupercanvas(chart.chartnumber, ctx, chart.wid, chart.hei, linecord, chart.container, chart.type);
			}
			if (charttype == 'splinechart') {
				$('#' + chart.container).css({
					'height': chart.hei + 100
				});
				$('#' + chart.container).html('<h2>' + chart.title.text + '</h2>');
				var ctx = preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);
				drawGrid(chart.chartnumber, 10, ctx, chart.data);
				var canvas = 'canvas' + chart.chartnumber;
				var maxdata = [];
				maxdata[0] = maxdata[1] = chart.data[0].datapoints[0].y;
				for (var i = 0; i < chart.data.length; i++) {
					for (var j = 0; j < chart.data[i].datapoints.length; j++) {
						if (chart.data[i].datapoints[j].y < maxdata[0]) {
							maxdata[0] = chart.data[i].datapoints[j].y;
						}
						if (chart.data[i].datapoints[j].y > maxdata[1]) {
							maxdata[1] = chart.data[i].datapoints[j].y;
						}
					}
				}
				//console.log(maxdata);
				var linecord = [];
				for (var i = 0; i < chart.data.length; i++) {
					drawsplinechart(canvas, ctx, 10, chart.data[i], maxdata, chart.data[i].stroke, linecord);
				}
				//console.log(linecord);
				var ctx = preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);
				drawupercanvas(chart.chartnumber, ctx, chart.wid, chart.hei, linecord, chart.container, chart.type);
			}
			if (charttype == 'barchart') {
				$('#' + chart.container).css({
					'height': chart.hei + 100
				});
				//console.log(chart);
				$('#' + chart.container).html('<h2>' + chart.title.text + '</h2>');
				var ctx = preparePlot(chart.chartnumber, chart.wid, chart.hei, chart.container);
				var verticaldevisions = chart.yaxis.max;
				//console.log(verticaldevisions);
				var barwidth = drawGrid(chart.chartnumber, verticaldevisions, ctx, chart.data);
				var canvas = 'canvas' + chart.chartnumber;
				var maxdata = [];
				maxdata[0] = maxdata[1] = chart.data[0].datapoints[0].y;
				for (var i = 0; i < chart.data.length; i++) {
					for (var j = 0; j < chart.data[i].datapoints.length; j++) {
						if (chart.data[i].datapoints[j].y < maxdata[0]) {
							maxdata[0] = chart.data[i].datapoints[j].y;
						}
						if (chart.data[i].datapoints[j].y > maxdata[1]) {
							maxdata[1] = chart.data[i].datapoints[j].y;
						}
					}
				}
				//console.log(maxdata);
				var linecord = [];
				var nextcurve = 0;
				var nextcurve = 30;
				for (var i = 0; i < chart.data.length; i++) {
					drawBar(canvas, ctx, verticaldevisions, chart.data[i], maxdata, nextcurve, chart.data[i].stroke, linecord, barwidth);
					nextcurve += barwidth;
				}
				drawGraphicLinearYcord(canvas, ctx, verticaldevisions, chart);
				//console.log(linecord);
				var ctx = preparePlotUpper(chart.chartnumber, chart.wid, chart.hei, chart.container);
				drawupercanvas(chart.chartnumber, ctx, chart.wid, chart.hei, linecord, chart.container, chart.type);
			}
			if (charttype == 'piechart') {
				$('#' + chart.container).css({
					'height': chart.hei + 100
				});
				$('#' + chart.container).html('<h2>' + chart.title.text + '</h2>');
				var ctx = preparePlot(chart.chartnumber, chart.hei, chart.hei, chart.container);
				drawGrid(chart.chartnumber, 10, ctx, chart.data);
				var canvas = 'canvas' + chart.chartnumber;
				var maxdata = [];
				maxdata[0] = maxdata[1] = chart.data[0].datapoints[0].y;
				for (var i = 0; i < chart.data.length; i++) {
					for (var j = 0; j < chart.data[i].datapoints.length; j++) {
						if (chart.data[i].datapoints[j].y < maxdata[0]) {
							maxdata[0] = chart.data[i].datapoints[j].y;
						}
						if (chart.data[i].datapoints[j].y > maxdata[1]) {
							maxdata[1] = chart.data[i].datapoints[j].y;
						}
					}
				}
				//console.log(maxdata);
				var linecord = [];
				for (var i = 0; i < chart.data.length; i++) {
					drawPie(canvas, ctx, 10, chart.data[i], maxdata, chart.data[i].stroke, linecord);
				}
				//console.log(linecord);
				var ctx = preparePlotUpper(chart.chartnumber, chart.hei, chart.hei, chart.container);
				drawupercanvas(chart.chartnumber, ctx, chart.wid, chart.hei, linecord, chart.container, chart.type);
			}
			if (charttype == 'donutchart') {
				$('#' + chart.container).css({
					'height': chart.hei + 100
				});
				$('#' + chart.container).html('<h2>' + chart.title.text + '</h2>');
				var ctx = preparePlot(chart.chartnumber, chart.hei, chart.hei, chart.container);
				drawGrid(chart.chartnumber, 10, ctx, chart.data);
				var canvas = 'canvas' + chart.chartnumber;
				var maxdata = [];
				maxdata[0] = maxdata[1] = chart.data[0].datapoints[0].y;
				for (var i = 0; i < chart.data.length; i++) {
					for (var j = 0; j < chart.data[i].datapoints.length; j++) {
						if (chart.data[i].datapoints[j].y < maxdata[0]) {
							maxdata[0] = chart.data[i].datapoints[j].y;
						}
						if (chart.data[i].datapoints[j].y > maxdata[1]) {
							maxdata[1] = chart.data[i].datapoints[j].y;
						}
					}
				}
				//console.log(maxdata);
				var linecord = [];
				var linewidth = 60;
				for (var i = 0; i < chart.data.length; i++) {
					drawDonut(canvas, ctx, 10, chart.data[i], maxdata, chart.data[i].stroke, linecord);
				}
				//console.log(linecord);
				var ctx = preparePlotUpper(chart.chartnumber, chart.hei, chart.hei, chart.container);
				drawupercanvas(chart.chartnumber, ctx, chart.wid, chart.hei, linecord, chart.container, chart.type);
			}
			if (charttype == 'meterchart') {
				$('#' + chart.container).css({
					'height': chart.hei + 100
				});
				$('#' + chart.container).html('<h2>' + chart.title.text + '</h2>');
				var ctx = preparePlot(chart.chartnumber, chart.hei, chart.hei, chart.container);
				drawGrid(chart.chartnumber, 10, ctx, chart.data);
				var canvas = 'canvas' + chart.chartnumber;
				var maxdata = [];
				maxdata[0] = maxdata[1] = chart.data[0].datapoints[0].y;
				for (var i = 0; i < chart.data.length; i++) {
					for (var j = 0; j < chart.data[i].datapoints.length; j++) {
						if (chart.data[i].datapoints[j].y < maxdata[0]) {
							maxdata[0] = chart.data[i].datapoints[j].y;
						}
						if (chart.data[i].datapoints[j].y > maxdata[1]) {
							maxdata[1] = chart.data[i].datapoints[j].y;
						}
					}
				}
				//console.log(maxdata);
				var linecord = [];
				var linewidth = 50;
				for (var i = 0; i < chart.data.length; i++) {
					drawMeter(canvas, ctx, 10, chart.data[i], maxdata, chart.data[i].stroke, linecord);
				}
				//console.log(linecord);
				var ctx = preparePlotUpper(chart.chartnumber, chart.hei, chart.hei, chart.container);
				drawupercanvas(chart.chartnumber, ctx, chart.wid, chart.hei, linecord, chart.container, chart.type);
			}
		}

		function prepSurface(nr, width, height, container) {
			//var container = document.getElementById(container);
			$('#' + container).append('<canvas id="canvas' + nr + '" class="canvas" style="position:absolute;" width="' + width + '" height="' + height + '"></canvas>');
			//document.write();
		}

		function prepUI(nr) {
			var canvas = document.getElementById('canvas' + nr);
			var ctx = canvas.getContext('2d');
			ctx.font = '12px helvetica';
			ctx.lineWidth = 1;
			return ctx;
		}

		function preparePlot(nr, sizex, sizey, container) {
			prepSurface(nr, sizex, sizey, container);
			var canvasContext = prepUI(nr);
			return canvasContext;
		}

		function prepSurfaceupper(nr, width, height, container) {
			var container = document.getElementById(container);
			container.insertAdjacentHTML('beforeend', '<canvas id="canvasupper' + nr + '" class="canvas" style="position:absolute;" width="' + width + '" height="' + height + '"></canvas> 		<div class="canvasjs-chart-tooltip" style="position: absolute; height: auto; box-shadow: rgba(0, 0, 0, 0.0980392) 1px 1px 2px 2px; z-index: 1000; display: none; border-radius: 5px; transition: left 0.2s ease-out, bottom 0.2s ease-out;"><div style="width: auto; height: auto; min-width: 50px; margin: 0px; padding: 5px; font-family: Calibri, Arial, Georgia, serif; font-weight: normal; font-style: italic; font-size: 14px; color: rgb(0, 0, 0); text-shadow: rgba(0, 0, 0, 0.0980392) 1px 1px 1px; text-align: left; border: 2px solid rgb(127, 96, 132); text-indent: 0px; white-space: nowrap; border-radius: 5px; -webkit-user-select: none; background: rgba(255, 255, 255, 0.901961);"><span style="color:#7F6084;"></span>3,125,844</div></div>');
			//container.innerHTML = '<canvas id="canvasupper'+nr+'" width="'+width+'" height="'+height+'"></canvas>'
			//document.write();
		}

		function prepUIUpper(nr) {
			var canvas = document.getElementById('canvasupper' + nr);
			var ctx = canvas.getContext('2d');
			ctx.font = '12px helvetica';
			ctx.lineWidth = 1;
			return ctx;
		}

		function preparePlotUpper(nr, sizex, sizey, container) {
			prepSurfaceupper(nr, sizex, sizey, container);
			var canvasContext = prepUIUpper(nr);
			return canvasContext;
		}

		function drawGrid(nr, verticanNr, ctx, data) {
			var canvas = document.getElementById('canvas' + nr);
			var hei = canvas.height - 60;
			var wid = canvas.width - 30;
			ctx.strokeStyle = 'rgba(0,0,0,1)';
			ctx.lineWidth = .5;
			var spacingVertical = hei / verticanNr;
			var spacingHorizontal = wid / data[0].datapoints.length;
			/*console.log(spacingVertical + 20);
			console.log(wid);*/
			
			if(data.length > 1){
				var barwidth = (spacingHorizontal - 15) / data.length;
			}else{
				var barwidth = 15;
			}
			ctx.beginPath();
			/*Horizontal grid*/
			for (var i = 0; i < data[0].datapoints.length + 1; i++) {
				ctx.moveTo(i * spacingHorizontal + 30, hei);
				ctx.lineTo(i * spacingHorizontal + 30, hei + 15);
			}
			ctx.stroke();
			/*Vertical grid*/
			for (var i = 0; i < verticanNr + 1; i++) {
				ctx.moveTo(30, i * spacingVertical);
				ctx.lineTo(wid+30, i * spacingVertical);
			}
			ctx.stroke();
			ctx.closePath();
			return barwidth;
		}

		function drawGraphicLinear(canvas, ctx, verticalNr, data, range, stroke, linecord) {
			var canvas = document.getElementById(canvas);
			var hei = canvas.height - 60;
			var wid = canvas.width - 30
			var spacingVertical = hei / verticalNr;
			var spacingHorizontal = wid / data.datapoints.length;
			
			var totalRange = range[1] - range[0];
			var verticalCoefficient = hei / totalRange;
			var mov;
			ctx.strokeStyle = stroke;
			ctx.beginPath();
			ctx.moveTo( spacingHorizontal / 2 , hei - (data.datapoints[0].y - range[0]) * verticalCoefficient);
			for (var i = 0; i < data.datapoints.length; i++) {
				//ctx.beginPath();
				ctx.strokeStyle = stroke;
				ctx.lineWidth = 1;
				ctx.lineTo(i * spacingHorizontal + spacingHorizontal / 2, hei - (data.datapoints[i].y - range[0]) * verticalCoefficient);
				//ctx.closePath();
				(function () {
					ctx.save();
					ctx.arc(i * spacingHorizontal + spacingHorizontal / 2, hei - (data.datapoints[i].y - range[0]) * verticalCoefficient, 1.5, 0, 2 * Math.PI)
					//ctx.fill();
					ctx.lineWidth = 3;
					ctx.restore();
				})()
				ctx.lineWidth = 1;/**/
				var newobj = {
					x: i * spacingHorizontal + spacingHorizontal / 2
					, y: hei - (data.datapoints[i].y - range[0]) * verticalCoefficient
					, lable: data.datapoints[i].lable
					, dataval: data.datapoints[i].y
				};
				//console.log(newobj);
				linecord.push(newobj);
				/*Fill Text as per cordinates*/
				//ctx.fillText(data.datapoints[i].y, i * spacingHorizontal, hei - (data.datapoints[i].y - range[0]) * verticalCoefficient + spacingVertical);
			}
			ctx.stroke();
			ctx.closePath();
			
			return linecord;
		}
		function drawGraphicLinearYcord(canvas, ctx, verticalNr, cdata){
			//console.log(cdata);
			var canvas = document.getElementById(canvas);
			var hei = canvas.height - 60;
			var wid = canvas.width - 30;
			var spacingVertical =  hei / verticalNr;
			var spacingHorizontal = wid / cdata.xaxis.categories.length;
			//console.log(spacingHorizontal);
			
			ctx.save();
			ctx.translate(0, canvas.height / 2);
			ctx.rotate(-Math.PI/2);
			ctx.textAlign = "center";
			ctx.fillText(cdata.yaxis.title, 0, 10);
			ctx.restore();
			
			/* xaxis Horizontal Documents*/
			ctx.save();
			ctx.font = "12px arial";
			ctx.fillStyle = "#000";
			var xangle;
			for(var i = 0; i < cdata.xaxis.categories.length; i++){
				if(ctx.measureText(cdata.xaxis.categories[i]).width > spacingHorizontal/1.1){
					xangle = 'a'; /*angular*/
					break;
				}else if(ctx.measureText(cdata.xaxis.categories[i]).width < spacingHorizontal/2){
					xangle = 'ms'; /*straight*/
				}/*else{
					xangle = 's'; medium straight
				}*/
			}
			if(xangle === 'a'){
				for (var i = 0; i < cdata.xaxis.categories.length; i++) {
					ctx.translate(i*spacingHorizontal + 32, hei + 8);
					ctx.rotate(Math.PI/4);
					ctx.fillText(cdata.xaxis.categories[i], 0, 0);
					//console.log(cdata.xaxis.categories[i], i*spacingHorizontal, hei-spacingVertical);
					ctx.rotate(-Math.PI/4);
					ctx.translate(-(i*spacingHorizontal + 32), -(hei + 8)); 	
				}
			}else{ /*if(xangle === 'ms'){
				for (var i = 0; i < cdata.xaxis.categories.length; i++) {
					ctx.fillText(cdata.xaxis.categories[i], i*spacingHorizontal + spacingHorizontal/2 + 30, hei + 15);
				}
			}else if(xangle === 's'){*/
				for (var i = 0; i < cdata.xaxis.categories.length; i++) {
					ctx.fillText(cdata.xaxis.categories[i], i*spacingHorizontal + 34, hei + 15);
				}
			}
			ctx.restore();
			
			/* yaxis Vertical Documents*/
			ctx.save();
			for (var i = 0; i < verticalNr + 1; i++) {
				var max = cdata.yaxis.max;
				var min = cdata.yaxis.min;
				var difference = cdata.yaxis.difference;
				ctx.fillText(i * difference, 10, canvas.height - (i*spacingVertical + 50));
			}
			ctx.restore();
			
		}

		function drawsplinechart(canvas, ctx, verticalNr, data, range, stroke, linecord) {
			var canvas = document.getElementById(canvas);
			var spacingVertical = canvas.height / verticalNr;
			var spacingHorizontal = canvas.width / data.datapoints.length;
			var hei = canvas.height - 3 * spacingVertical;
			var totalRange = range[1] - range[0];
			var verticalCoefficient = hei / totalRange;
			var mov;
			ctx.strokeStyle = stroke;
			ctx.beginPath();
			for (var i = 0; i < data.datapoints.length - 1; i++) {
				ctx.moveTo(i * spacingHorizontal, hei - (data.datapoints[i].y - range[0]) * verticalCoefficient + spacingVertical);
				//console.log(i*spacingHorizontal, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical);
				/*if(i == 0){
					if(data.datapoints[i].y < data.datapoints[i+1].y ){
						var anglepoint = 10;
						ctx.bezierCurveTo(i*spacingHorizontal + anglepoint, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical + anglepoint,  (i + 1) * spacingHorizontal - anglepoint, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical - anglepoint, (i + 1) * spacingHorizontal, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical);
					}else{
						var anglepoint = -10;
						ctx.bezierCurveTo(i*spacingHorizontal + anglepoint, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical + anglepoint,  (i + 1) * spacingHorizontal - anglepoint, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical - anglepoint, (i + 1) * spacingHorizontal, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical);
					}
				}else if(i == data.datapoints.length){
					if(data.datapoints[i].y < data.datapoints[i+1].y ){
						var anglepoint = 10;
						ctx.bezierCurveTo(i*spacingHorizontal + anglepoint, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical + anglepoint,  (i + 1) * spacingHorizontal - anglepoint, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical - anglepoint, (i + 1) * spacingHorizontal, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical);
					}else{
						var anglepoint = -10;
						ctx.bezierCurveTo(i*spacingHorizontal + anglepoint, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical + anglepoint,  (i + 1) * spacingHorizontal - anglepoint, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical - anglepoint, (i + 1) * spacingHorizontal, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical);
					}
				}else{
					if(data.datapoints[i].y < data.datapoints[i+1].y ){
						var anglepoint = 10;
						ctx.bezierCurveTo(i*spacingHorizontal + anglepoint, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical + anglepoint,  (i + 1) * spacingHorizontal - anglepoint, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical - anglepoint, (i + 1) * spacingHorizontal, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical);
					}else{
						var anglepoint = -10;
						ctx.bezierCurveTo(i*spacingHorizontal + anglepoint, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical + anglepoint,  (i + 1) * spacingHorizontal - anglepoint, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical - anglepoint, (i + 1) * spacingHorizontal, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical);
					}
				}*/
				ctx.bezierCurveTo(i * spacingHorizontal + 10, hei - (data.datapoints[i].y - range[0]) * verticalCoefficient + spacingVertical + 15, (i + 1) * spacingHorizontal - 10, hei - (data.datapoints[i + 1].y - range[0]) * verticalCoefficient + spacingVertical - 15, (i + 1) * spacingHorizontal, hei - (data.datapoints[i + 1].y - range[0]) * verticalCoefficient + spacingVertical);
				//console.log(i*spacingHorizontal, hei-(data.datapoints[i].y-range[0])*verticalCoefficient+spacingVertical + 15,  (i + 1) * spacingHorizontal - 10, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical - 15, (i + 1) * spacingHorizontal, hei-(data.datapoints[i+1].y-range[0])*verticalCoefficient+spacingVertical);
				var newobj = {
					x: i * spacingHorizontal
					, y: hei - (data.datapoints[i].y - range[0]) * verticalCoefficient + spacingVertical
					, lable: data.datapoints[i].lable
				};
				//console.log(newobj);
				linecord.push(newobj);
				ctx.fillText(data.datapoints[i].y, i * spacingHorizontal, hei - (data.datapoints[i].y - range[0]) * verticalCoefficient + spacingVertical);
			}
			ctx.stroke();
			for (var i = 0; i < linecord.length; i++) {
				//console.log(linecord[i]);
				ctx.beginPath();
				ctx.arc(i * spacingHorizontal, hei - (data.datapoints[i].y - range[0]) * verticalCoefficient + spacingVertical, 2, 0, 2 * Math.PI);
				ctx.fill();
				ctx.stroke();
			}
			ctx.closePath();
			return linecord;
		}

		function drawupercanvas(nr, ctx, width, height, linecord, container, charttype) {
			//var canvasid = document.getElementById('canvasupper'+nr);
			if (charttype == 'linechartcomparision') {
				for (var i = 0; i < linecord.length; i++) {
					//console.log(linecord[i]);
					ctx.beginPath();
					ctx.arc(linecord[i].x, linecord[i].y, 3, 0, 2 * Math.PI);
					//ctx.fill();
					//ctx.stroke();
				}
				document.getElementById('canvasupper' + nr).addEventListener('mousemove', function (evt) {
					ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
					var mousePos = getMousePos(document.getElementById('canvasupper' + nr), evt);
					//console.log(mousePos);
					var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
					for (var i = 0; i < linecord.length; i++) {
						ctx.beginPath();
						ctx.arc(linecord[i].x, linecord[i].y, 4, 0, 2 * Math.PI);
						if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {
							ctx.lineWidth = 4;
							ctx.strokeStyle = 'rgba(0,0,0,.5)';
							ctx.stroke();
							//ctx.fill();
							$('#' + container + ' .canvasjs-chart-tooltip').css({
								'display': 'block'
								, 'left': linecord[i].x
								, 'top': linecord[i].y
							});
							$('#' + container + ' .canvasjs-chart-tooltip div').html(linecord[i].lable + ' : ' + linecord[i].dataval);
							break;
						}
						else {
							ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
							//$('#'+container+' .canvasjs-chart-tooltip').css({'display':'none'});
						}
					}
				}, false);
				document.getElementById('canvasupper' + nr).addEventListener('mouseout', function (evt) {
					setTimeout(function(){
						$('#' + container + ' .canvasjs-chart-tooltip').css({
							'display': 'none'
						});
					}, 2000);
				});
			}
			if (charttype == 'barchart') {
				document.getElementById('canvasupper' + nr).addEventListener('mousemove', function (evt) {
					ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
					var mousePos = getMousePos(document.getElementById('canvasupper' + nr), evt);
					//console.log(mousePos);
					var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
					//					/console.log(message);
					for (var i = 0; i < linecord.length; i++) {
						ctx.beginPath();
						ctx.rect(linecord[i].x, linecord[i].y, linecord[i].wid, linecord[i].hei);
						if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {
							ctx.lineWidth = .5;
							ctx.fillStyle = 'rgba(0,0,0,.3)'
							ctx.fill();
							ctx.stroke();
							$('#' + container + ' .canvasjs-chart-tooltip').css({
								'display': 'block'
								, 'left': linecord[i].x
								, 'top': linecord[i].y
							});
							$('#' + container + ' .canvasjs-chart-tooltip div').html(linecord[i].lable + ' : ' + linecord[i].dataval);
							break;
						}
						else {
							ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
							//$('#'+container+' .canvasjs-chart-tooltip').css({'display':'none'});
						}
					}
				}, false);
				document.getElementById('canvasupper' + nr).addEventListener('mouseout', function (evt) {
					setTimeout(function(){
						$('#' + container + ' .canvasjs-chart-tooltip').css({
							'display': 'none'
						});
					}, 2000);
				});
			}
			if (charttype == 'piechart') {
				document.getElementById('canvasupper' + nr).addEventListener('mousemove', function (evt) {
					ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
					var mousePos = getMousePos(document.getElementById('canvasupper' + nr), evt);
					var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
					//console.log(message);
					for (var i = 0; i < linecord.length; i++) {
						ctx.beginPath();
						ctx.lineTo(linecord[i].x, linecord[i].x);
						ctx.arc(linecord[i].x, linecord[i].x, linecord[i].x, linecord[i].startangle, linecord[i].lastangle, false);
						ctx.lineTo(linecord[i].x, linecord[i].x);
						if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {
							/*ctx.lineWidth=1;
							ctx.stroke();*/
							ctx.fillStyle = 'rgba(0,0,0,.3)'
							ctx.fill();
							$('#' + container + ' .canvasjs-chart-tooltip').css({
								'display': 'block'
								, 'left': mousePos.x
								, 'top': mousePos.y
							});
							$('#' + container + ' .canvasjs-chart-tooltip div').html(linecord[i].lable + ' : ' + linecord[i].y);
							break;
						}
						else {
							ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
							//$('#'+container+' .canvasjs-chart-tooltip').css({'display':'none'});
							/*ctx.fillStyle = 'rgba(255,255,255,0)';
							ctx.strokeStyle="#FF0000";
							ctx.lineWidth=0;*/
						}
						//
					}
				}, false);
				document.getElementById('canvasupper' + nr).addEventListener('mouseout', function (evt) {
					setTimeout(function(){
						ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
						$('#' + container + ' .canvasjs-chart-tooltip').css({
							'display': 'none'
						});
					}, 2000);
				});
			}
			if (charttype == 'donutchart') {
				document.getElementById('canvasupper' + nr).addEventListener('mousemove', function (evt) {
					ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
					var linewidth = 50;
					var mousePos = getMousePos(document.getElementById('canvasupper' + nr), evt);
					var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
					//console.log(message);
					for (var i = 0; i < linecord.length; i++) {
						ctx.lineWidth = 70;
						ctx.beginPath();
						//ctx.lineTo(linecord[i].x, linecord[i].x);
						ctx.arc(linecord[i].x, linecord[i].x, linecord[i].x - linewidth, linecord[i].startangle, linecord[i].lastangle, false);
						//ctx.lineTo(linecord[i].x, linecord[i].x);
						if (ctx.isPointInStroke(mousePos.x, mousePos.y)) {
							/*ctx.lineWidth=1;*/
							ctx.strokeStyle = "rgba(0,0,0,0.2)";
							ctx.stroke();
							$('#' + container + ' .canvasjs-chart-tooltip').css({
								'display': 'block'
								, 'left': mousePos.x
								, 'top': mousePos.y + 5
							});
							$('#' + container + ' .canvasjs-chart-tooltip div').html(linecord[i].lable + ' : ' + linecord[i].y);
							break;
						}
						if (!(ctx.isPointInStroke(mousePos.x, mousePos.y))) {
							ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
						}
					}
				}, false);
				document.getElementById('canvasupper' + nr).addEventListener('mouseout', function (evt) {
					setTimeout(function(){
						ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
						$('#' + container + ' .canvasjs-chart-tooltip').css({
							'display': 'none'
						});
					}, 2000);
				});
			}
			if (charttype == 'splinechart') {
				/*for (var i = 0; i < linecord.length; i++) {
					//console.log(linecord[i]);
					ctx.beginPath();
					ctx.arc(linecord[i].x, linecord[i].y, 5, 0, 2 * Math.PI);
					ctx.stroke();
				}*/
				ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
				document.getElementById('canvasupper' + nr).addEventListener('mousemove', function (evt) {
					var mousePos = getMousePos(document.getElementById('canvasupper' + nr), evt);
					//console.log(mousePos);
					var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
					for (var i = 0; i < linecord.length; i++) {
						ctx.beginPath();
						ctx.arc(linecord[i].x, linecord[i].y, 5, 0, 2 * Math.PI);
						if (ctx.isPointInStroke(mousePos.x, mousePos.y) || ctx.isPointInPath(mousePos.x, mousePos.y)) {
							ctx.lineWidth = 4;
							ctx.strokeStyle = 'rgba(0,0,0,.5)';
							ctx.stroke();
							$('#' + container + ' .canvasjs-chart-tooltip').css({
								'display': 'block'
								, 'left': linecord[i].x
								, 'top': linecord[i].y + 5
							});
							$('#' + container + ' .canvasjs-chart-tooltip div').html(linecord[i].lable);
							break;
						}
						if (!(ctx.isPointInStroke(mousePos.x, mousePos.y))) {
							ctx.clearRect(0, 0, document.getElementById('canvasupper' + nr).width, document.getElementById('canvasupper' + nr).height);
						}
					}
				}, false);
				document.getElementById('canvasupper' + nr).addEventListener('mouseout', function (evt) {
					setTimeout(function(){
						$('#' + container + ' .canvasjs-chart-tooltip').css({
							'display': 'none'
						});
					}, 2000);
				});
			}
		}

		function drawBar(canvas, ctx, verticalNr, data, range, curx, stroke, linecord, barwidth) {
			var canvas = document.getElementById(canvas);
			var hei = canvas.height - 60;
			var wid = canvas.width - 30;
			var spacingVertical = hei / verticalNr;
			var spacingHorizontal = wid / data.datapoints.length;
			/*console.log(spacingHorizontal);
			console.log(wid);*/
			var totalcompare = data.datapoints.length;
			//var barwidth = 15;
			ctx.beginPath();
			ctx.strokeStyle = stroke;
			//ctx.moveTo(0, hei-(data[0]-range[0])*verticalCoefficient+spacingVertical);
			for (var i = 0; i < data.datapoints.length; i++) {
				ctx.fillStyle = stroke;
				var h = (data.datapoints[i].y / range[1]) * hei;
				ctx.fillRect(curx, hei - h, barwidth, h);
				var newobj = {
					x: curx
					, y: hei - h
					, wid: barwidth
					, hei: h
					, lable: data.datapoints[i].lable
					, dataval : data.datapoints[i].y
				};
				//console.log(newobj);
				linecord.push(newobj);
				ctx.fillStyle = "#000";
				//ctx.fillText(data.datapoints[i].y, curx, hei - h);
				curx += spacingHorizontal;
			}
			ctx.stroke();
			ctx.closePath();
			return linecord;
		}

		function drawPie(canvas, ctx, verticalNr, data, range, stroke, linecord) {
			var canvas = document.getElementById(canvas);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			var lastend = 0;
			var myTotal = 0; // Automatically calculated so don't touch
			var radius = canvas.height / 2;
			for (var e = 0; e < data.datapoints.length; e++) {
				myTotal += data.datapoints[e].y;
			}
			for (var i = 0; i < data.datapoints.length; i++) {
				ctx.fillStyle = data.datapoints[i].color;
				ctx.beginPath();
				ctx.moveTo(canvas.width / 2, canvas.height / 2);
				if (data.datapoints[i].y == 0) {
					ctx.arc(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)), false);
					//console.log(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)));
					ctx.lineTo(canvas.width / 2, canvas.height / 2);
					ctx.strokeStyle = '1';
					ctx.strokeStyle = '#fff';
					ctx.stroke();
				}
				ctx.arc(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)), false);
				//console.log(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)));
				ctx.lineTo(canvas.width / 2, canvas.height / 2);
				var newobj = {
					x: canvas.width / 2
					, startangle: lastend
					, lastangle: lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal))
					, lable: data.datapoints[i].lable
					, y: data.datapoints[i].y
				};
				//console.log(newobj);
				linecord.push(newobj);
				lastend += Math.PI * 2 * (data.datapoints[i].y / myTotal);
				//console.log(lastend);
				ctx.fill();
			}
			/* Draw piechart number values and numbers*/
			var angle = 0;
			var x = Math.floor(canvas.width / 2);
			var y = Math.floor(canvas.height / 2);
			ctx.fillStyle = "#fff";
			ctx.font = radius * 0.10 + "px arial";
			for (i = 0; i < data.datapoints.length; i++) {
				if (data.datapoints[i].y != 0) {
					anglenew = (Math.PI * 2 * (data.datapoints[i].y / myTotal));
					var anglemiddle = anglenew / 3;
					var fx = radius + (radius*.7) * Math.cos(angle + anglemiddle);
					var fy = radius + (radius*.7) * Math.sin(angle + anglemiddle);
					//ctx.moveTo(x, y);
					ctx.translate(fx, fy);
					//ctx.rotate(angle + anglemiddle);
					ctx.fillText(data.datapoints[i].y.toString(), 0, 0 /*x + radius / 1.3, y*/);
					ctx.translate(-fx, -fy);
					angle += (Math.PI * 2 * (data.datapoints[i].y / myTotal));
				}
			}
			return linecord;
		}

		function drawDonut(canvas, ctx, verticalNr, data, range, stroke, linecord) {
			var canvas = document.getElementById(canvas);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			var linewidth = 50;
			ctx.lineWidth = 70;
			var lastend = 0;
			var myTotal = 0; // Automatically calculated so don't touch
			var radius = canvas.height / 2 - linewidth;
			for (var e = 0; e < data.datapoints.length; e++) {
				myTotal += data.datapoints[e].y;
			}
			for (var i = 0; i < data.datapoints.length; i++) {
				if (data.datapoints[i].y == 0) {
					ctx.beginPath();
					ctx.arc(canvas.width / 2, canvas.height / 2, radius, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)), false);
					ctx.strokeStyle = '#fff';
					ctx.stroke()
				}
				ctx.strokeStyle = data.datapoints[i].color;
				ctx.beginPath();
				//ctx.moveTo(canvas.width / 2, canvas.height / 2);
				ctx.arc(canvas.width / 2, canvas.height / 2, radius, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)), false);
				//console.log(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)));
				//ctx.lineTo(canvas.width / 2, canvas.height / 2);
				var newobj = {
					x: canvas.width / 2
					, startangle: lastend
					, lastangle: lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal))
					, lable: data.datapoints[i].lable
					, y: data.datapoints[i].y
				};
				//console.log(newobj);
				linecord.push(newobj);
				lastend += Math.PI * 2 * (data.datapoints[i].y / myTotal);
				//console.log(lastend);
				//ctx.fill();				
				ctx.stroke();
			}
			/* Draw piechart number values */
			var angle = 0;
			var x = Math.floor(canvas.width / 2);
			var y = Math.floor(canvas.height / 2);
			ctx.fillStyle = "#fff";
			ctx.font = radius * 0.12 + "px arial";
			for (i = 0; i < data.datapoints.length; i++) {
				/*if (data.datapoints[i].y != 0) {
					anglenew = (Math.PI * 2 * (data.datapoints[i].y / myTotal));
					var anglemiddle = (anglenew - angle) / 2;
					ctx.translate(x, y);
					ctx.rotate(angle + anglemiddle);
					ctx.translate(-x, -y);
					ctx.fillText(data.datapoints[i].y.toString(), x + radius, y);
					angle = (Math.PI * 2 * (data.datapoints[i].y / myTotal));
				}*/
				if (data.datapoints[i].y != 0) {
					anglenew = (Math.PI * 2 * (data.datapoints[i].y / myTotal));
					var anglemiddle = anglenew / 3;
					var fx = (radius * 1.5) + radius * Math.cos(angle+anglemiddle);
					var fy = (radius * 1.5) + radius * Math.sin(angle+anglemiddle);
					//ctx.moveTo(x, y);
					ctx.translate(fx, fy);
					//ctx.rotate(angle + anglemiddle);
					ctx.fillText(data.datapoints[i].y.toString(), 0, 0 /*x + radius / 1.3, y*/);
					ctx.translate(-fx, -fy);
					angle += (Math.PI * 2 * (data.datapoints[i].y / myTotal));
				}
			}
			return linecord;
		}

		function drawMeter(canvas, ctx, verticalNr, data, range, stroke, linecord) {
			var canvas = document.getElementById(canvas);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			var linewidth = 50;
			ctx.lineWidth = 4;
			var lastend = 3.141592653589793;
			var myTotal = 0; // Automatically calculated so don't touch
			var radius = canvas.height / 2 - linewidth;
			for (var e = 0; e < data.datapoints.length; e++) {
				myTotal += data.datapoints[e].y;
			}
			for (var i = 0; i < data.datapoints.length; i++) {
				ctx.strokeStyle = "#fff";
				ctx.fillStyle = data.datapoints[i].color;
				ctx.beginPath();
				ctx.moveTo(canvas.width / 2, canvas.height / 2);
				ctx.arc(canvas.width / 2, canvas.height / 2, radius, lastend, lastend + (Math.PI * (data.datapoints[i].y / myTotal)));
				//console.log(canvas.width / 2, canvas.height / 2, canvas.height / 2, lastend, lastend + (Math.PI * 2 * (data.datapoints[i].y / myTotal)));
				ctx.lineTo(canvas.width / 2, canvas.height / 2);
				ctx.fill();
				ctx.stroke();
				var newobj = {
					x: canvas.width / 2
					, startangle: lastend
					, lastangle: lastend + (Math.PI * (data.datapoints[i].y / myTotal))
					, lable: data.datapoints[i].lable
				};
				linecord.push(newobj);
				lastend += Math.PI * (data.datapoints[i].y / myTotal);
			}
			//console.log(linecord);
			ctx.beginPath();
			ctx.fillStyle = "#fff";
			ctx.arc(canvas.width / 2, canvas.height / 2, radius * 0.7, 0, 2 * Math.PI);
			ctx.fill();
			ctx.closePath();
			ctx.beginPath();
			ctx.fillStyle = "#000";
			ctx.arc(canvas.width / 2, canvas.height / 2, radius * 0.1, 0, 2 * Math.PI);
			ctx.fill();
			ctx.closePath();
			ctx.beginPath();
			var rotateangel = Math.PI * (data.dataval / 100) + 3.141592653589793;
			//console.log(rotateangel);
			var headlen = 10;
			ctx.lineWidth = 6;
			ctx.lineCap = "round";
			var tox = canvas.width / 2 + (radius * .8) * Math.cos(rotateangel);
			var toy = canvas.height / 2 + (radius * .8) * Math.sin(rotateangel);
			var fromx = canvas.width / 2;
			var fromy = canvas.height / 2;
			ctx.moveTo(canvas.width / 2, canvas.height / 2);
			ctx.lineTo(tox, toy);
			ctx.strokeStyle = "#000";
			ctx.stroke();
			ctx.beginPath();
			ctx.fillStyle = "#fff";
			ctx.arc(canvas.width / 2, canvas.height / 2, radius * 0.07, 0, 2 * Math.PI);
			ctx.fill();
			ctx.closePath();
			/* Draw piechart number values */
			var angle = 3.141592653589793;
			var x = Math.floor(canvas.width / 2);
			var y = Math.floor(canvas.height / 2);
			ctx.fillStyle = "#000";
			ctx.font ="14px arial";
			ctx.save();
			for (i = 0; i < data.datapoints.length; i++) {
				anglenew = (Math.PI * 2 * (data.datapoints[i].y / myTotal)) / 2;
				var anglemiddle = anglenew / 6;
				/*ctx.translate(x, y);
				ctx.rotate(angle + anglemiddle);
				ctx.translate(-x, -y);
				ctx.fillText(data.datapoints[i].lable.toString(), x + radius, y);
				angle = (Math.PI * (data.datapoints[i].y / myTotal)) - anglemiddle;*/
				//console.log(angle);

				var fx = canvas.width / 2 + (radius*1.01) * Math.cos(angle + anglemiddle);
				var fy = canvas.height / 2 + (radius*1.01) * Math.sin(angle + anglemiddle);
				ctx.translate(fx, fy);
				ctx.rotate(angle + 1.8);
				ctx.fillText(data.datapoints[i].lable.toString(), 0, 0);
				ctx.rotate(-(angle + 1.8));
				ctx.translate(-fx, -fy);
				angle += (Math.PI * (data.datapoints[i].y / myTotal));
			}
			ctx.restore();
			return linecord;
		}
		/*function drawmultiBar(canvas, ctx, verticalNr, data, range, stroke, linecord){
			var canvas = document.getElementById('canvas'+nr);
			var spacingVertical = canvas.height/verticalNr;
			var spacingHorizontal = canvas.width/data.datapoints.length;
			var hei = canvas.height-spacingVertical;
			var width = 20;
			var curx = 0;
			
			ctx.beginPath();
			ctx.strokeStyle = stroke;
			//ctx.moveTo(0, hei-(data[0]-range[0])*verticalCoefficient+spacingVertical);
			
			for(var i = 0; i<data.datapoints.length;i++){
				var h = (data.datapoints[i].y/range[1])*hei;
				var h1 = ((data1[i]/range[1])*hei)+h;
				var h2 = ((data2[i]/range[1])*hei)+h1;

					ctx.fillStyle = plot1;
					ctx.fillRect(curx, hei - h2 , width, h2);

					ctx.fillStyle = text;
					ctx.fillRect(curx, hei - h1, width, h1);

					ctx.fillStyle = plot;
					ctx.fillRect(curx, hei - h , width, h);

				ctx.fillStyle = '#bbb';
				ctx.fillText(data2[i], curx, hei-h2+10);
				ctx.fillText(data1[i], curx, hei-h1+10);
				ctx.fillText(data[i], curx, hei-h+10);
				
				curx +=  spacingHorizontal;
			}
			ctx.stroke();
			ctx.closePath();
		}*/
		function enumerateIt(nr, hei, spacv, spach) {
			var data = data2;
			ctx.fillStyle = text;
			for (var i = 0; i < data.length; i++) {
				ctx.fillText(i + 1, spach * i + 4, hei + 2 * spacv + 20);
			}
		}

		function writeMessage(canvas, message) {
			ctx.font = '18pt Calibri';
			ctx.fillStyle = 'black';
			ctx.fillText(message, 10, 25);
		}

		function getMousePos(canvas, evt) {
			var rect = canvas.getBoundingClientRect();
			return {
				x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width
				, y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height
			};
		}
	</script>
</body>

</html>
